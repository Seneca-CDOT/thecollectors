function MapGenerator(numStructs, difficulty){
	this.mapGraph=new Graph();
	this.structureList=[];
	this.numStructs=numStructs;
	//Based on the difficulty, fill the pool with possible denominators
	var pool=DenominatorPool.easy;
	if(difficulty == 2 || difficulty == 3){
		pool=pool.concat(DenominatorPool.normal);
		if(difficulty == 3)
			pool=pool.concat(DenominatorPool.hard);	
	}
	this.fuel=pool[rng(0,pool.length-1)];
	this.generateMapGraph();
}
MapGenerator.prototype.generateMapGraph = function() {
	this.mapGraph.clearGraph();
	this.index=0;
	this.generateRawGraph();
	this.cleanGraph();
	if(!this.startPoint)
		this.generateStructures();
}
/*	
	internal function which should only be called by generateMapGraph()
	Will generate a raw Graph object
	The Graph generated by this function has incomplete and improper connections	
*/
MapGenerator.prototype.generateRawGraph = function(){
	var node=new Node(this.index++,rng(50,screenSizeX/5),rng(50,screenSizeY/5));
	var nodeID=this.mapGraph.addNode(node);
	var roadCap=this.numStructs*roadsPerStructure; 				//maximum number of roads to generate
	var prevHeading=0;

	//distanceCap is the # of different road distances possible
	var distanceCap=Math.round(this.fuel / 2);
	for(var i=1; i<=roadCap;i++){	
		var x,y;
		var distance=rng(1,distanceCap);
		distance=baseRoadLength*distance;

		//generate a heading that isn't in the same direction or opposite direction of the previous heading
		if(prevHeading==1)
			var heading=rng(5,8);
		else if(prevHeading==2)
			var heading=rng(0,4);
		else
			var heading=rng(0,8);
		if(heading<5) prevHeading=1;
		else prevHeading=2;
		switch(heading){
			case 0:
			case 1:
			case 2:
				x=node.vertex.x;
				y=node.vertex.y-distance;
				if(y<50)
					heading=3;
				else	
					break;
			case 3:
			case 4:
				x=node.vertex.x;
				y=node.vertex.y+distance;
				break;
			case 5:
			case 6:
				x=node.vertex.x-distance;
				y=node.vertex.y;
				if(x<50){
					heading=7;
				}
				else
					break;
			case 7:
			case 8:
				x=node.vertex.x+distance;
				y=node.vertex.y;
				break;
		}
		//creates a new Node based on the generated distance and heading
		var node2=new Node(this.index++,x,y);
		var node2ID=this.mapGraph.addNode(node2);

		//conenct the new node to the previous node
		this.mapGraph.addConnection(node2ID,nodeID);
		nodeID=node2ID; 
		node=node2;
	}
}
/*	
	Internal function to be called only by generateMapGraph()
	Takes the Graph generated by generateRawGraph() and maps it's intersection points
*/
MapGenerator.prototype.cleanGraph = function(){
	var nodes=this.mapGraph.nodeDictionary;
	var edges=this.mapGraph.getEdgeList();
	var tmpGraph= new Graph();
	var j=0;
	//find intersection points and create connections to reflect these intersections
	for(var index in edges){
		var node1=nodes[index];
		for (var i = edges[index].length - 1; i >= 0; i--) {
			var node2=nodes[edges[index][i]];
			var intersectCheck=this.mapGraph.edgeIntersects(node1.vertex.x,node1.vertex.y,node2.vertex.x,node2.vertex.y)
			if(intersectCheck){			
				var node1ID=new Node(j, node1.vertex.x, node1.vertex.y);
				node1ID=tmpGraph.addNode(node1ID);
				if(node1ID==j)j++;
				var node2ID=new Node(j, node2.vertex.x, node2.vertex.y);
				node2ID=tmpGraph.addNode(node2ID); if(node2ID==j)j++;
				for (var i = intersectCheck.length - 1; i >= 0; i--) {
					if(!intersectCheck[i].colinear){
						var intNode=new Node(j, intersectCheck[i].x, intersectCheck[i].y);
						intNode=tmpGraph.addNode(intNode); if(intNode==j)j++;
						var node3=new Node(j, intersectCheck[i].x1, intersectCheck[i].y1);
						node3=tmpGraph.addNode(node3); if(node3==j)j++;
						var node4=new Node(j, intersectCheck[i].x2, intersectCheck[i].y2);
						node4=tmpGraph.addNode(node4); if(node4==j)j++;
						var tmpNodes=tmpGraph.nodeDictionary;
						tmpGraph.addConnection(intNode,node1ID, 
							new Fraction(distance(tmpNodes[intNode].vertex,tmpNodes[node1ID].vertex)/baseRoadLength,this.fuel));
						tmpGraph.addConnection(intNode,node2ID,
							new Fraction(distance(tmpNodes[intNode].vertex,tmpNodes[node2ID].vertex)/baseRoadLength,this.fuel));
						tmpGraph.addConnection(intNode,node3,
							new Fraction(distance(tmpNodes[intNode].vertex,tmpNodes[node3].vertex)/baseRoadLength,this.fuel));
						tmpGraph.addConnection(intNode,node4,
							new Fraction(distance(tmpNodes[intNode].vertex,tmpNodes[node4].vertex)/baseRoadLength,this.fuel));
					}
				}
			}
		}
	}
	//necessary to remove extraneous nodes that persisted due to colinear lines
	nodes=tmpGraph.nodeDictionary;
	for(var index in nodes){
		var node1=nodes[index];
		for(var indx in node1.connections){
			var node2=nodes[indx];
			for(var indekkusu in node1.connections){
				if(indx != indekkusu){
					var node3=nodes[indekkusu];
					var intersectCheck=segIntersection(node1.vertex.x, node1.vertex.y,
														node2.vertex.x, node2.vertex.y,
														node1.vertex.x, node1.vertex.y,
														node3.vertex.x, node3.vertex.y);
					//colinear lines found that connect to the same node
					if(intersectCheck.colinear){
						var dist1=distance(node1.vertex,node2.vertex);
						var dist2=distance(node1.vertex,node3.vertex);
						//if both lines have the same "direction", remove the connection with the farther node
						//possible bug here...further testing is necessary
						if(node1.vertex.extendedSlope(node2.vertex) == node1.vertex.extendedSlope(node3.vertex)){
							if(dist1<dist2){
								tmpGraph.removeConnection(node1.id, node3.id);
							}
						}
					}
				}
			}
		}
	}
	//run minConnections() on each Node to see if a one-direction path has been generated
	//if minConnections() is not satisfied, generate a new map
	this.mapGraph=tmpGraph; var invalid=false;
	for(var index in this.mapGraph.nodeDictionary){
		if(!this.minConnections(-1,index,0)){
			invalid=true;
			break;
		} 
	}
	if(invalid) this.generateMapGraph();
}
/*
	Recursive Algorithim to test if a node or one of its nearby connected
	nodes has at least 3 connections, a.k.a not making a one direction path.
	Currently tests a chain of up to 3 nodes
*/
MapGenerator.prototype.minConnections = function(nodeFrom, nodeIn, hops){
	var node=this.mapGraph.nodeDictionary[nodeIn];
	if(node.connectionsLength <= 2){
		if(hops == 3)
			return false;
		else{
			for(var index in node.connections){
				if(index!=nodeFrom){
					var rv=this.minConnections(nodeIn,index,hops+1);
					if(!rv) return false;
				}
			}
			return true;
		}
	}
	else return true;
}
/*
	Generates structures...
*/
MapGenerator.prototype.generateStructures = function(){
	var nodes = this.mapGraph.nodeDictionary;
	var structCount=0;
	if(numStructureTypes%structsPerPoints == 0)
		var hopSize=2;
	else
		var hopSize=3;
	hopSize=hopSize*structsPerPoints;
	//	generates structures at dead-ends
	for(var index in nodes){
		if(nodes[index].connectionsLength==1 && !this.findStructure(-1,index,this.fuel)){
			this.structureList.push(new Structure(index,
				this.randomStructureType(hopSize*structCount%numStructureTypes)));
			structCount++;
		}
	}
	//	Every loop reduces the fuel amount passed into findStructure
	//	This makes it easier to return false, and then generate a structure
	var loops = 0;
	while(structCount != this.numStructs){
		for(var index in nodes){
			if(structCount == this.numStructs) break;
			if(!this.findStructure(-1,index, this.fuel-loops)){
				this.structureList.push(new Structure(index,
					this.randomStructureType(hopSize*structCount%numStructureTypes)));
				structCount++;
			}
		}
		loops++;
	}
	
	//	Randomizing a start point for the player
	//	Want to make sure the start point isn't on or too close to a structure
	//	loops variable protects against looping too many times/infinite loops
	loops=0;
	do{
		this.startPoint = this.mapGraph.randomNode();
		loops++;
	}
	while(this.findStructure(-1,this.startPoint.id,this.fuel-loops/2));
}
/*
	Recursive check for a nearby structure that can be reached with
	the fuel specified by fuelAmt
*/
MapGenerator.prototype.findStructure = function(nodeFrom, nodeIn, fuelAmt, findFuel){
	if(fuelAmt <= 0)
		return false;
	var structureAtNode = this.getStructureFromList(nodeIn);
	if(structureAtNode){
		if(structureAtNode.StructType == "fuel" && findFuel)
			return fuelAmt;
		else if(structureAtNode.StructType != "fuel" && !findFuel)
			return true;
	}
	var node=this.mapGraph.nodeDictionary[nodeIn];
	for(var index in node.connections){
		if(index!=nodeFrom){
			var rv=this.findStructure(nodeIn,index,fuelAmt-node.connections[index].numerator,findFuel);
			if(rv!=false) return rv;
		}
	}
	return false;
}
MapGenerator.prototype.placeFuelStation = function(nodeID){
	var rv = this.findStructure(-1,nodeID,this.fuel/2,true);
	if(!rv){
		if(!this.getStructureFromList(nodeID)){
			this.structureList.push(new Structure(nodeID,"fuel"));
			return true;
		}
		console.log("why would you try that?");
	}
	console.log("too close!");
	return false;
}
/*
	Returns the structure in structureList at the specified node ID
*/
MapGenerator.prototype.getStructureFromList = function(nodeID) {
	for (var i = this.structureList.length - 1; i >= 0; i--) {
		if(this.structureList[i].nodeID == nodeID)
			return this.structureList[i];
	}
	return false;
}
/*
	Returns a structure type ot use for generation
*/
MapGenerator.prototype.randomStructureType = function(_loops){
	var loops = 0;
	var returnNext = 0;
	for(var index in StructureValues){
		if(returnNext){
			if(returnNext==1)
				return index;
			else
				returnNext--;
		}
		if(loops == _loops){
			var rand = rng(1,structsPerPoints);
			if(rand==1) return index;
			else returnNext = structsPerPoints-1;
		}
		loops++;
	}
}